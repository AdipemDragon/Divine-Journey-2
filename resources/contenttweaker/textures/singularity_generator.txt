# Paste it into a program that can read Python like PyCharm or iPython Notebook

import numpy as np
import imageio
import math
from PIL import Image

path = '' # Fill it out, e.g. 'C:/Users/yourname/Documents/singularities'
orig_img_name = 'singularity_base_gray.png' # A base singularity texture

def generate_singularity(path, orig_img_name, savename, new_color=[255,0,0], mode='geometric', angle_per_frame=10, padding_size=16):
    
    img_path = path + '/' + orig_img_name
    
    def add_padding(img):
        padded_pixels = np.array(img)
        padded_pixels = np.append(padded_pixels, [[np.array([255,255,255,0], dtype='uint8') for i in range(len(padded_pixels))] for j in range(padding_size)], axis=0)
        padded_pixels = np.append(padded_pixels, [[np.array([255,255,255,0], dtype='uint8')  for j in range(padding_size)] for i in range(len(padded_pixels))], axis=1)
        padded_pixels = np.append([[np.array([255,255,255,0], dtype='uint8') for i in range(len(padded_pixels))] for j in range(padding_size)], padded_pixels, axis=0)
        padded_pixels = np.append([[np.array([255,255,255,0], dtype='uint8') for j in range(padding_size)] for i in range(len(padded_pixels))], padded_pixels, axis=1)
        return Image.fromarray(padded_pixels, 'RGBA')

    def remove_padding(img):
        pixels = np.array(img)
        pixels = pixels[padding_size:len(pixels)-padding_size]
        pixels = np.transpose(pixels, axes = [1,0,2])
        pixels = pixels[padding_size:len(pixels)-padding_size]
        pixels = np.transpose(pixels, axes = [1,0,2])
        return Image.fromarray(pixels, 'RGBA')
    
    def rotate_by(img,angle):
        alpha = angle*math.pi/180
        original_pixels = img.load()
        modified_image = Image.new(img.mode,img.size)
        pixels = modified_image.load()
        c = np.transpose(np.array([math.ceil(img.size[0]/2),math.ceil(img.size[1]/2)]))
        cosalpha = math.cos(alpha)
        sinalpha = math.sin(alpha)
        A = np.array([[cosalpha,-sinalpha],[sinalpha,cosalpha]])
        for i in range(modified_image.size[0]):
            for j in range(modified_image.size[1]):
                if (i-c[0])**2+(j-c[1])**2 < min(c)**2:
                    o_rel = np.transpose(np.array([i,j]))-c
                    rotated_o_rel = np.dot(A,o_rel)
                    rotated = rotated_o_rel + c
                    pixels[i,j] = original_pixels[rotated[0],rotated[1]]
                else:
                    pixels[i,j] = original_pixels[i,j]
        return modified_image
    
    
    img = Image.open(img_path).convert('RGBA')
    new_pixels = np.array(img)
    padded_img = add_padding(img)
    
    for i in range(angle_per_frame,360,angle_per_frame):
        rotated_img = np.array(remove_padding(rotate_by(padded_img,i)))
        new_pixels = np.append(new_pixels, rotated_img, axis=0)
    
    def colorize(pixels,rgb_color,mode):
        ret_pixels = pixels
        for i in range(len(pixels)):
            for j in range(len(pixels[0])):
                cur_color = pixels[i][j][:3]
                if list(cur_color) != [255,255,255]:
                    if mode == 'avg':
                        new_color = [math.ceil(c) for c in (cur_color + rgb_color) / 2]
                    elif mode == 'geometric':
                        new_color = [math.ceil(math.sqrt(c)) for c in cur_color * rgb_color]
                    elif mode == 'harmonic':
                        modified_rgb_color = np.array([1 if r == 0 else r for r in rgb_color])
                        modified_cur_color = np.array([1 if r == 0 else r for r in cur_color])
                        new_color = [math.ceil(c) for c in 1 / ((1 / modified_cur_color + 1 / modified_rgb_color)/2)]
                    elif mode == 'min':
                        new_color = [min(m) for m in [(cur_color[k],rgb_color[k]) for k in range(3)]]
                    elif mode == 'max':
                        new_color = [max(m) for m in [(cur_color[k],rgb_color[k]) for k in range(3)]]
                    else:
                        new_color = rgb_color
                    ret_pixels[i][j] = np.append(new_color,pixels[i][j][3])
        return ret_pixels

    new_img = Image.fromarray(colorize(new_pixels,new_color,mode), 'RGBA')
    ew_img.save(str(path) + '/' + str(savename))


# Examples:
# generate_singularity(path, orig_img_name, 'red.png', new_color=[255,0,0], mode='min')
# generate_singularity(path, orig_img_name, 'light_green.png', new_color=[0,255,0], mode='avg')